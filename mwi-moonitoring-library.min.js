/**
 * MWI Moonitoring - WebSocket Event Library for Milky Way Idle
 * @version 0.1.0
 * @author c3d.gg
 * @license MIT
 * @homepage https://github.com/mathewcst/mwi-moonitoring
 *
 * A high-performance, non-blocking library for intercepting and processing
 * WebSocket events in Milky Way Idle. Designed to be used by multiple addons
 * simultaneously without conflicts.
 *
 * IMPORTANT: This is a LIBRARY, not a userscript. Use it via @require:
 * // @require https://raw.githubusercontent.com/mathewcst/mwi-moonitoring/main/mwi-moonitoring-library.js
 *
 * @example
 * // In your userscript header:
 * // @require https://raw.githubusercontent.com/mathewcst/mwi-moonitoring/main/mwi-moonitoring-library.js
 *
 * // In your script:
 * MWIWebSocket.on('init_character_data', (eventType, data) => {
 *   console.log('Character loaded:', data.character.name);
 * });
 *
 * @credits Original WebSocket hook technique by YangLeda
 */
!function(e){"use strict";if(e.MWIWebSocket&&e.MWIWebSocket._initialized)return;const t="0.1.0",s="MWI-Moonitoring",i={enableBatching:!0,batchInterval:100,maxBatchSize:50,preParsing:!0,eventWhitelist:[],eventBlacklist:[],enableDiscovery:!1,discoveryLimit:100,debug:!1,logLevel:"warn",historySize:50,enableCache:!0,cacheSize:100,errorHandling:"isolate",maxListenersPerEvent:100},r=["api.milkywayidle.com/ws","api-test.milkywayidle.com/ws"],o={deepClone(e){if(null===e||"object"!=typeof e)return e;if(e instanceof Date)return new Date(e.getTime());if(e instanceof Array)return e.map(e=>o.deepClone(e));if(e instanceof Object){const t={};for(const s in e)e.hasOwnProperty(s)&&(t[s]=o.deepClone(e[s]));return t}},matchesPattern(e,t){if(!t.includes("*"))return e===t;return new RegExp("^"+t.replace(/\*/g,".*")+"$").test(e)},throttle(e,t){let s;return function(...i){s||(e.apply(this,i),s=!0,setTimeout(()=>s=!1,t))}},safeParse(e){try{return JSON.parse(e)}catch(e){return null}},now:()=>performance.now()};class n{constructor(e){this.config=e,this.levels={error:0,warn:1,info:2,debug:3}}_shouldLog(e){return!!this.config.debug&&this.levels[e]<=this.levels[this.config.logLevel]}_format(e,t,...i){return[`[${s}] [${e.toUpperCase()}]`,t,...i]}error(e,...t){this._shouldLog("error")&&console.error(...this._format("error",e,...t))}warn(e,...t){this._shouldLog("warn")&&console.warn(...this._format("warn",e,...t))}info(e,...t){this._shouldLog("info")&&console.info(...this._format("info",e,...t))}debug(e,...t){this._shouldLog("debug")&&console.log(...this._format("debug",e,...t))}}class c{constructor(e,t){this.config=e,this.logger=t,this.events=new Map,this.onceEvents=new Set}on(e,t){if("function"!=typeof t)throw new TypeError("Callback must be a function");return(Array.isArray(e)?e:[e]).forEach(e=>{this.events.has(e)||this.events.set(e,new Set);const s=this.events.get(e);s.size>=this.config.maxListenersPerEvent?this.logger.warn(`Max listeners (${this.config.maxListenersPerEvent}) reached for event: ${e}`):(s.add(t),this.logger.debug(`Listener added for event: ${e}`))}),()=>this.off(e,t)}once(e,t){const s=(...i)=>{this.off(e,s),t(...i)};return this.onceEvents.add(s),this.on(e,s)}off(e,t){(Array.isArray(e)?e:[e]).forEach(e=>{const s=this.events.get(e);s&&(s.delete(t),0===s.size&&this.events.delete(e),this.logger.debug(`Listener removed for event: ${e}`))})}offAll(e){e?(this.events.delete(e),this.logger.debug(`All listeners removed for event: ${e}`)):(this.events.clear(),this.onceEvents.clear(),this.logger.debug("All listeners removed"))}emit(e,t){const s=new Set;return this.events.has(e)&&this.events.get(e).forEach(e=>s.add(e)),this.events.forEach((t,i)=>{i.includes("*")&&o.matchesPattern(e,i)&&t.forEach(e=>s.add(e))}),s.forEach(s=>{try{if("isolate"===this.config.errorHandling)setTimeout(()=>{try{s(e,t)}catch(t){this.logger.error(`Error in listener for ${e}:`,t)}},0);else if("suppress"===this.config.errorHandling)try{s(e,t)}catch(t){this.logger.error(`Error in listener for ${e}:`,t)}else s(e,t)}catch(t){this.logger.error(`Fatal error in listener for ${e}:`,t)}}),s.size}listenerCount(e){if(!e){let e=0;return this.events.forEach(t=>e+=t.size),e}const t=this.events.get(e);return t?t.size:0}eventNames(){return Array.from(this.events.keys())}}class h{constructor(){this.metrics={totalEvents:0,eventsPerType:new Map,processingTimes:[],avgProcessingTime:0,peakProcessingTime:0,droppedEvents:0,errors:0,startTime:Date.now(),lastReset:Date.now()},this.maxSamples=1e3}recordEvent(e,t){this.metrics.totalEvents++;const s=this.metrics.eventsPerType.get(e)||0;this.metrics.eventsPerType.set(e,s+1),this.metrics.processingTimes.push(t),this.metrics.processingTimes.length>this.maxSamples&&this.metrics.processingTimes.shift(),this.metrics.avgProcessingTime=this.metrics.processingTimes.reduce((e,t)=>e+t,0)/this.metrics.processingTimes.length,t>this.metrics.peakProcessingTime&&(this.metrics.peakProcessingTime=t)}recordError(){this.metrics.errors++}recordDropped(){this.metrics.droppedEvents++}getMetrics(){const e=Date.now()-this.metrics.startTime,t=this.metrics.totalEvents/(e/1e3);return{...this.metrics,uptime:e,eventsPerSecond:t.toFixed(2),topEvents:Array.from(this.metrics.eventsPerType.entries()).sort((e,t)=>t[1]-e[1]).slice(0,10)}}reset(){this.metrics.totalEvents=0,this.metrics.eventsPerType.clear(),this.metrics.processingTimes=[],this.metrics.avgProcessingTime=0,this.metrics.peakProcessingTime=0,this.metrics.droppedEvents=0,this.metrics.errors=0,this.metrics.lastReset=Date.now()}}class a{constructor(e,t){this.config=e,this.logger=t,this.discoveries=new Map,this.isDiscovering=!1,this.discoveryResolve=null}start(e=6e4){return this.isDiscovering?Promise.reject(new Error("Discovery already in progress")):(this.isDiscovering=!0,this.discoveries.clear(),this.logger.info(`Starting event discovery for ${e}ms`),new Promise(t=>{this.discoveryResolve=t,setTimeout(()=>{this.stop()},e)}))}stop(){if(!this.isDiscovering)return;this.isDiscovering=!1;const e=this.getResults();this.logger.info(`Discovery complete. Found ${e.length} event types`),this.discoveryResolve&&(this.discoveryResolve(e),this.discoveryResolve=null)}record(e,t){if(!this.isDiscovering)return;if(this.discoveries.size>=this.config.discoveryLimit)return;this.discoveries.has(e)||this.discoveries.set(e,{type:e,count:0,firstSeen:Date.now(),lastSeen:Date.now(),samples:[]});const s=this.discoveries.get(e);s.count++,s.lastSeen=Date.now(),s.samples.length<3&&s.samples.push({timestamp:Date.now(),data:o.deepClone(t)})}getResults(){return Array.from(this.discoveries.values()).sort((e,t)=>t.count-e.count)}}class l{constructor(e,t){this.config=e,this.processor=t,this.queue=[],this.timer=null,this.processing=!1}add(e){this.config.enableBatching?(this.queue.push(e),this.timer||(this.timer=setTimeout(()=>this.flush(),this.config.batchInterval)),this.queue.length>=this.config.maxBatchSize&&this.flush()):this.processor([e])}flush(){if(this.processing||0===this.queue.length)return;this.processing=!0,this.timer&&(clearTimeout(this.timer),this.timer=null);const e=this.queue.splice(0,this.config.maxBatchSize);try{this.processor(e)}catch(e){console.error("[MWI-Moonitoring] Batch processing error:",e)}finally{this.processing=!1,this.queue.length>0&&!this.timer&&(this.timer=setTimeout(()=>this.flush(),this.config.batchInterval))}}clear(){this.queue=[],this.timer&&(clearTimeout(this.timer),this.timer=null)}size(){return this.queue.length}}const g=new class{constructor(){this.config={...i},this.logger=new n(this.config),this.emitter=new c(this.config,this.logger),this.monitor=new h,this.discovery=new a(this.config,this.logger),this.queue=new l(this.config,this.processBatch.bind(this)),this.isHooked=!1,this.originalGet=null,this.eventHistory=[],this.eventCache=new Map,this._initialized=!0}installHook(){if(this.isHooked)this.logger.debug("WebSocket already hooked");else try{const e=Object.getOwnPropertyDescriptor(MessageEvent.prototype,"data");if(!e||!e.get)throw new Error("Cannot access MessageEvent.prototype.data");this.originalGet=e.get;const t=this;e.get=function(){const e=this.currentTarget;if(!(e instanceof WebSocket))return t.originalGet.call(this);if(!r.some(t=>e.url&&e.url.indexOf(t)>-1))return t.originalGet.call(this);const s=t.originalGet.call(this);return Object.defineProperty(this,"data",{value:s}),setTimeout(()=>t.processMessage(s),0),s},Object.defineProperty(MessageEvent.prototype,"data",e),this.isHooked=!0,this.logger.info("WebSocket hook installed successfully")}catch(e){throw this.logger.error("Failed to install WebSocket hook:",e),e}}removeHook(){if(this.isHooked&&this.originalGet)try{const e=Object.getOwnPropertyDescriptor(MessageEvent.prototype,"data");e.get=this.originalGet,Object.defineProperty(MessageEvent.prototype,"data",e),this.isHooked=!1,this.originalGet=null,this.logger.info("WebSocket hook removed")}catch(e){this.logger.error("Failed to remove WebSocket hook:",e)}}processMessage(e){const t=o.now();try{if("string"!=typeof e||e.length<2)return;if("{"!==e[0]&&"["!==e[0])return;if(this.config.preParsing&&!e.includes('"type"'))return;const s=o.safeParse(e);if(!s||!s.type)return;if(this.config.eventBlacklist.includes(s.type))return void this.monitor.recordDropped();if(this.config.eventWhitelist.length>0&&!this.config.eventWhitelist.includes(s.type))return void this.monitor.recordDropped();this.queue.add({type:s.type,data:s,timestamp:Date.now()}),(this.config.enableDiscovery||this.discovery.isDiscovering)&&this.discovery.record(s.type,s);const i=o.now()-t;this.monitor.recordEvent(s.type,i)}catch(e){this.monitor.recordError(),this.logger.error("Error processing message:",e)}}processBatch(e){const t=o.now();e.forEach(e=>{try{if(this.eventHistory.length>=this.config.historySize&&this.eventHistory.shift(),this.eventHistory.push(e),this.config.enableCache&&(this.eventCache.set(e.type,e),this.eventCache.size>this.config.cacheSize)){const e=this.eventCache.keys().next().value;this.eventCache.delete(e)}const t=this.emitter.emit(e.type,e.data);t>0&&this.logger.debug(`Event ${e.type} emitted to ${t} listeners`)}catch(t){this.monitor.recordError(),this.logger.error(`Error processing event ${e.type}:`,t)}});const s=o.now()-t;s>10&&this.logger.warn(`Batch processing took ${s.toFixed(2)}ms for ${e.length} messages`)}configure(e){this.config={...this.config,...e},this.logger=new n(this.config),this.emitter.config=this.config,this.discovery.config=this.config,this.queue.config=this.config,this.logger.info("Configuration updated:",e)}getConfig(){return{...this.config}}getEventHistory(e){return e?this.eventHistory.slice(-e):[...this.eventHistory]}getCachedEvent(e){return this.eventCache.get(e)}clear(){this.eventHistory=[],this.eventCache.clear(),this.queue.clear(),this.monitor.reset(),this.logger.info("All data cleared")}};let f=!1;const u=()=>{f||(g.installHook(),f=!0)},d={version:t,_initialized:!0,on:(e,t)=>(u(),g.emitter.on(e,t)),once:(e,t)=>(u(),g.emitter.once(e,t)),off:(e,t)=>g.emitter.off(e,t),offAll:e=>g.emitter.offAll(e),emit:(e,t)=>g.emitter.emit(e,t),async discover(e=6e4){u();const t=g.config.enableDiscovery;g.configure({enableDiscovery:!0});const s=await g.discovery.start(e);return g.configure({enableDiscovery:t}),s},getEventHistory:e=>g.getEventHistory(e),getEventTypes:()=>g.emitter.eventNames(),getEventCount:e=>e?g.monitor.metrics.eventsPerType.get(e)||0:g.monitor.metrics.totalEvents,getCachedEvent:e=>g.getCachedEvent(e),getMetrics:()=>g.monitor.getMetrics(),resetMetrics(){g.monitor.reset()},enableProfiling(e){g.configure({debug:e,logLevel:e?"debug":"warn"})},configure(e){g.configure(e)},getConfig:()=>g.getConfig(),isReady:()=>g.isHooked,waitForReady:()=>new Promise(e=>{g.isHooked?e():(u(),setTimeout(e,100))}),listenerCount:e=>g.emitter.listenerCount(e),installHook(){g.installHook(),f=!0},removeHook(){g.removeHook(),f=!1},clear(){g.clear()},destroy(){g.removeHook(),g.emitter.offAll(),g.clear(),f=!1}};e.MWIWebSocket=d,"undefined"!=typeof module&&module.exports&&(module.exports=d),"function"==typeof define&&define.amd&&define([],function(){return d}),console.log(`[${s}] v${t} loaded successfully. Use MWIWebSocket.on() to subscribe to events.`)}("undefined"!=typeof window?window:this);