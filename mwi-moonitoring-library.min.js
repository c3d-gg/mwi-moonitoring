/**
 * MWI Moonitoring - READ-ONLY WebSocket Event Library for Milky Way Idle
 * @version 0.1.0
 * @author c3d.gg
 * @license MIT
 * @homepage https://github.com/mathewcst/mwi-moonitoring
 *
 * ⚠️ TOS COMPLIANCE WARNING:
 * This library is READ-ONLY and only monitors incoming WebSocket messages.
 * It does NOT and CANNOT send messages to the game server.
 * Any automation that sends commands violates the game's Terms of Service.
 * 
 * A high-performance, non-blocking library for intercepting and processing
 * WebSocket events in Milky Way Idle. Designed to be used by multiple addons
 * simultaneously without conflicts.
 *
 * IMPORTANT: This is a LIBRARY, not a userscript. Use it via @require:
 * // @require https://cdn.c3d.gg/mwi-moonitoring-library.min.js
 *
 * @example
 * // In your userscript header:
 * // @require https://cdn.c3d.gg/mwi-moonitoring-library.min.js
 *
 * // In your script (READ-ONLY operations):
 * MWIWebSocket.on('init_character_data', (eventType, data) => {
 *   console.log('Character loaded:', data.character.name);
 *   // ✅ OK: Reading and displaying data
 *   // ❌ NOT OK: Sending commands or automating gameplay
 * });
 *
 * @credits Original WebSocket hook technique by YangLeda
 */
!function(e){"use strict";if(e.MWIWebSocket&&e.MWIWebSocket._initialized)return;const t="0.1.0",i="MWI-Moonitoring",s={enableBatching:!0,batchInterval:100,maxBatchSize:50,preParsing:!0,eventWhitelist:[],eventBlacklist:[],enableDiscovery:!1,discoveryLimit:100,debug:!1,logLevel:"warn",historySize:50,enableCache:!0,cacheSize:100,errorHandling:"isolate",maxListenersPerEvent:100},r=["api.milkywayidle.com/ws","api-test.milkywayidle.com/ws"],o={deepClone(e){if(null===e||"object"!=typeof e)return e;if(e instanceof Date)return new Date(e.getTime());if(e instanceof Array)return e.map(e=>o.deepClone(e));if(e instanceof Object){const t={};for(const i in e)e.hasOwnProperty(i)&&(t[i]=o.deepClone(e[i]));return t}},matchesPattern(e,t){if(!t.includes("*"))return e===t;return new RegExp("^"+t.replace(/\*/g,".*")+"$").test(e)},throttle(e,t){let i;return function(...s){i||(e.apply(this,s),i=!0,setTimeout(()=>i=!1,t))}},safeParse(e){try{return JSON.parse(e)}catch(e){return null}},now:()=>performance.now()};class n{constructor(e){this.config=e,this.levels={error:0,warn:1,info:2,debug:3}}_shouldLog(e){return!!this.config.debug&&this.levels[e]<=this.levels[this.config.logLevel]}_format(e,t,...s){return[`[${i}] [${e.toUpperCase()}]`,t,...s]}error(e,...t){this._shouldLog("error")&&console.error(...this._format("error",e,...t))}warn(e,...t){this._shouldLog("warn")&&console.warn(...this._format("warn",e,...t))}info(e,...t){this._shouldLog("info")&&console.info(...this._format("info",e,...t))}debug(e,...t){this._shouldLog("debug")&&console.log(...this._format("debug",e,...t))}}class c{constructor(e,t){this.config=e,this.logger=t,this.events=new Map,this.onceEvents=new Set}on(e,t){if("function"!=typeof t)throw new TypeError("Callback must be a function");return(Array.isArray(e)?e:[e]).forEach(e=>{this.events.has(e)||this.events.set(e,new Set);const i=this.events.get(e);i.size>=this.config.maxListenersPerEvent?this.logger.warn(`Max listeners (${this.config.maxListenersPerEvent}) reached for event: ${e}`):(i.add(t),this.logger.debug(`Listener added for event: ${e}`))}),()=>this.off(e,t)}once(e,t){const i=(...s)=>{this.off(e,i),t(...s)};return this.onceEvents.add(i),this.on(e,i)}off(e,t){(Array.isArray(e)?e:[e]).forEach(e=>{const i=this.events.get(e);i&&(i.delete(t),0===i.size&&this.events.delete(e),this.logger.debug(`Listener removed for event: ${e}`))})}offAll(e){e?(this.events.delete(e),this.logger.debug(`All listeners removed for event: ${e}`)):(this.events.clear(),this.onceEvents.clear(),this.logger.debug("All listeners removed"))}emit(e,t){const i=new Set;return this.events.has(e)&&this.events.get(e).forEach(e=>i.add(e)),this.events.forEach((t,s)=>{s.includes("*")&&o.matchesPattern(e,s)&&t.forEach(e=>i.add(e))}),i.forEach(i=>{try{if("isolate"===this.config.errorHandling)setTimeout(()=>{try{i(e,t)}catch(t){this.logger.error(`Error in listener for ${e}:`,t)}},0);else if("suppress"===this.config.errorHandling)try{i(e,t)}catch(t){this.logger.error(`Error in listener for ${e}:`,t)}else i(e,t)}catch(t){this.logger.error(`Fatal error in listener for ${e}:`,t)}}),i.size}listenerCount(e){if(!e){let e=0;return this.events.forEach(t=>e+=t.size),e}const t=this.events.get(e);return t?t.size:0}eventNames(){return Array.from(this.events.keys())}}class h{constructor(){this.metrics={totalEvents:0,eventsPerType:new Map,processingTimes:[],avgProcessingTime:0,peakProcessingTime:0,droppedEvents:0,errors:0,startTime:Date.now(),lastReset:Date.now()},this.maxSamples=1e3}recordEvent(e,t){this.metrics.totalEvents++;const i=this.metrics.eventsPerType.get(e)||0;this.metrics.eventsPerType.set(e,i+1),this.metrics.processingTimes.push(t),this.metrics.processingTimes.length>this.maxSamples&&this.metrics.processingTimes.shift(),this.metrics.avgProcessingTime=this.metrics.processingTimes.reduce((e,t)=>e+t,0)/this.metrics.processingTimes.length,t>this.metrics.peakProcessingTime&&(this.metrics.peakProcessingTime=t)}recordError(){this.metrics.errors++}recordDropped(){this.metrics.droppedEvents++}getMetrics(){const e=Date.now()-this.metrics.startTime,t=this.metrics.totalEvents/(e/1e3);return{...this.metrics,uptime:e,eventsPerSecond:t.toFixed(2),topEvents:Array.from(this.metrics.eventsPerType.entries()).sort((e,t)=>t[1]-e[1]).slice(0,10)}}reset(){this.metrics.totalEvents=0,this.metrics.eventsPerType.clear(),this.metrics.processingTimes=[],this.metrics.avgProcessingTime=0,this.metrics.peakProcessingTime=0,this.metrics.droppedEvents=0,this.metrics.errors=0,this.metrics.lastReset=Date.now()}}class a{constructor(e,t){this.config=e,this.logger=t,this.discoveries=new Map,this.isDiscovering=!1,this.discoveryResolve=null}start(e=6e4){return this.isDiscovering?Promise.reject(new Error("Discovery already in progress")):(this.isDiscovering=!0,this.discoveries.clear(),this.logger.info(`Starting event discovery for ${e}ms`),new Promise(t=>{this.discoveryResolve=t,setTimeout(()=>{this.stop()},e)}))}stop(){if(!this.isDiscovering)return;this.isDiscovering=!1;const e=this.getResults();this.logger.info(`Discovery complete. Found ${e.length} event types`),this.discoveryResolve&&(this.discoveryResolve(e),this.discoveryResolve=null)}record(e,t){if(!this.isDiscovering)return;if(this.discoveries.size>=this.config.discoveryLimit)return;this.discoveries.has(e)||this.discoveries.set(e,{type:e,count:0,firstSeen:Date.now(),lastSeen:Date.now(),samples:[]});const i=this.discoveries.get(e);i.count++,i.lastSeen=Date.now(),i.samples.length<3&&i.samples.push({timestamp:Date.now(),data:o.deepClone(t)})}getResults(){return Array.from(this.discoveries.values()).sort((e,t)=>t.count-e.count)}}class l{constructor(e,t){this.config=e,this.processor=t,this.queue=[],this.timer=null,this.processing=!1,this.logger=null}updateConfig(e){const t=this.config.batchInterval;this.config=e,this.logger=new n(this.config),t!==e.batchInterval&&this.timer&&(this.logger.debug(`Restarting batch timer: ${t}ms → ${e.batchInterval}ms`),clearTimeout(this.timer),this.timer=setTimeout(()=>this.flush(),this.config.batchInterval))}add(e){this.config.enableBatching?(this.queue.push(e),this.timer||(this.logger&&this.logger.debug(`Starting batch timer with ${this.config.batchInterval}ms interval (queue: ${this.queue.length})`),this.timer=setTimeout(()=>this.flush(),this.config.batchInterval)),this.queue.length>=this.config.maxBatchSize&&this.flush()):this.processor([e])}flush(){if(this.processing||0===this.queue.length)return;this.processing=!0,this.timer&&(clearTimeout(this.timer),this.timer=null);const e=this.queue.splice(0,this.config.maxBatchSize);try{this.processor(e)}catch(e){console.error("[MWI-Moonitoring] Batch processing error:",e)}finally{this.processing=!1,this.queue.length>0&&!this.timer&&(this.logger&&this.logger.debug(`Scheduling next batch timer with ${this.config.batchInterval}ms interval (remaining: ${this.queue.length})`),this.timer=setTimeout(()=>this.flush(),this.config.batchInterval))}}clear(){this.queue=[],this.timer&&(clearTimeout(this.timer),this.timer=null)}size(){return this.queue.length}}const g=new class{constructor(){this.config={...s},this.logger=new n(this.config),this.emitter=new c(this.config,this.logger),this.monitor=new h,this.discovery=new a(this.config,this.logger),this.queue=new l(this.config,this.processBatch.bind(this)),this.queue.updateConfig(this.config),this.isHooked=!1,this.originalGet=null,this.eventHistory=[],this.eventCache=new Map,this._initialized=!0}installHook(){if(this.isHooked)this.logger.debug("WebSocket already hooked");else try{const e=Object.getOwnPropertyDescriptor(MessageEvent.prototype,"data");if(!e||!e.get)throw new Error("Cannot access MessageEvent.prototype.data");this.originalGet=e.get;const t=this;e.get=function(){const e=this.currentTarget;if(!(e instanceof WebSocket))return t.originalGet.call(this);if(!r.some(t=>e.url&&e.url.indexOf(t)>-1))return t.originalGet.call(this);const i=t.originalGet.call(this);return Object.defineProperty(this,"data",{value:i}),setTimeout(()=>t.processMessage(i),0),i},Object.defineProperty(MessageEvent.prototype,"data",e),this.isHooked=!0,this.logger.info("WebSocket hook installed successfully")}catch(e){throw this.logger.error("Failed to install WebSocket hook:",e),e}}removeHook(){if(this.isHooked&&this.originalGet)try{const e=Object.getOwnPropertyDescriptor(MessageEvent.prototype,"data");e.get=this.originalGet,Object.defineProperty(MessageEvent.prototype,"data",e),this.isHooked=!1,this.originalGet=null,this.logger.info("WebSocket hook removed")}catch(e){this.logger.error("Failed to remove WebSocket hook:",e)}}processMessage(e){const t=o.now();try{if("string"!=typeof e||e.length<2)return;if("{"!==e[0]&&"["!==e[0])return;if(this.config.preParsing&&!e.includes('"type"'))return;const i=o.safeParse(e);if(!i||!i.type)return;if(this.config.eventBlacklist.includes(i.type))return void this.monitor.recordDropped();if(this.config.eventWhitelist.length>0&&!this.config.eventWhitelist.includes(i.type))return void this.monitor.recordDropped();this.queue.add({type:i.type,data:i,timestamp:Date.now()}),(this.config.enableDiscovery||this.discovery.isDiscovering)&&this.discovery.record(i.type,i);const s=o.now()-t;this.monitor.recordEvent(i.type,s)}catch(e){this.monitor.recordError(),this.logger.error("Error processing message:",e)}}processBatch(e){const t=o.now();e.forEach(e=>{try{if(this.eventHistory.length>=this.config.historySize&&this.eventHistory.shift(),this.eventHistory.push(e),this.config.enableCache&&(this.eventCache.set(e.type,e),this.eventCache.size>this.config.cacheSize)){const e=this.eventCache.keys().next().value;this.eventCache.delete(e)}const t=this.emitter.emit(e.type,e.data);t>0&&this.logger.debug(`Event ${e.type} emitted to ${t} listeners`)}catch(t){this.monitor.recordError(),this.logger.error(`Error processing event ${e.type}:`,t)}});const i=o.now()-t;i>10&&this.logger.warn(`Batch processing took ${i.toFixed(2)}ms for ${e.length} messages`)}configure(e){const t={...this.config};this.config={...this.config,...e},this.logger=new n(this.config),this.emitter.config=this.config,this.discovery.config=this.config,this.queue.updateConfig(this.config),this.logger.info("Configuration updated:",{...e,_batchIntervalChanged:t.batchInterval!==this.config.batchInterval})}getConfig(){return{...this.config}}getEventHistory(e){return e?this.eventHistory.slice(-e):[...this.eventHistory]}getCachedEvent(e){return this.eventCache.get(e)}clear(){this.eventHistory=[],this.eventCache.clear(),this.queue.clear(),this.monitor.reset(),this.logger.info("All data cleared")}};let u=!1;const f=()=>{u||(g.installHook(),u=!0)},d={version:t,_initialized:!0,on:(e,t)=>(f(),g.emitter.on(e,t)),once:(e,t)=>(f(),g.emitter.once(e,t)),off:(e,t)=>g.emitter.off(e,t),offAll:e=>g.emitter.offAll(e),emit:(e,t)=>g.emitter.emit(e,t),async discover(e=6e4){f();const t=g.config.enableDiscovery;g.configure({enableDiscovery:!0});const i=await g.discovery.start(e);return g.configure({enableDiscovery:t}),i},getEventHistory:e=>g.getEventHistory(e),getEventTypes:()=>g.emitter.eventNames(),getEventCount:e=>e?g.monitor.metrics.eventsPerType.get(e)||0:g.monitor.metrics.totalEvents,getCachedEvent:e=>g.getCachedEvent(e),getMetrics:()=>g.monitor.getMetrics(),resetMetrics(){g.monitor.reset()},enableProfiling(e){g.configure({debug:e,logLevel:e?"debug":"warn"})},configure(e){g.configure(e)},getConfig:()=>g.getConfig(),isReady:()=>g.isHooked,waitForReady:()=>new Promise(e=>{g.isHooked?e():(f(),setTimeout(e,100))}),listenerCount:e=>g.emitter.listenerCount(e),installHook(){g.installHook(),u=!0},removeHook(){g.removeHook(),u=!1},clear(){g.clear()},destroy(){g.removeHook(),g.emitter.offAll(),g.clear(),u=!1}};e.MWIWebSocket=d,"undefined"!=typeof module&&module.exports&&(module.exports=d),"function"==typeof define&&define.amd&&define([],function(){return d}),console.log(`[${i}] v${t} loaded successfully. Use MWIWebSocket.on() to subscribe to events.`)}("undefined"!=typeof window?window:this);