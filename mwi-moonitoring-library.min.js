/**
 * MWI Moonitoring - READ-ONLY WebSocket Event Library for Milky Way Idle
 * @version 0.2.2
 * @author c3d.gg
 * @license MIT
 * @homepage https://github.com/mathewcst/mwi-moonitoring
 *
 * ⚠️ TOS COMPLIANCE WARNING:
 * This library is READ-ONLY and only monitors incoming WebSocket messages.
 * It does NOT and CANNOT send messages to the game server.
 * Any automation that sends commands violates the game's Terms of Service.
 *
 * A high-performance, non-blocking library for intercepting and processing
 * WebSocket events in Milky Way Idle. Designed to be used by multiple addons
 * simultaneously without conflicts.
 *
 * @credits Original WebSocket hook technique by YangLeda
 */
!function(e){"use strict";if(e.MWIWebSocket&&e.MWIWebSocket._initialized)return;const t="0.2.2",s="MWI-Moonitoring",i={enableBatching:!0,batchInterval:100,maxBatchSize:50,preParsing:!0,eventWhitelist:[],eventBlacklist:[],enableDiscovery:!1,discoveryLimit:100,debug:!1,logLevel:"warn",historySize:50,enableCache:!0,cacheSize:100,errorHandling:"isolate",maxListenersPerEvent:100},r=["api.milkywayidle.com/ws","api-test.milkywayidle.com/ws"],n={deepClone(e){if(null===e||"object"!=typeof e)return e;if(e instanceof Date)return new Date(e.getTime());if(e instanceof Array)return e.map(e=>n.deepClone(e));if(e instanceof Object){const t={};for(const s in e)e.hasOwnProperty(s)&&(t[s]=n.deepClone(e[s]));return t}},matchesPattern(e,t){if(!t.includes("*"))return e===t;return new RegExp("^"+t.replace(/\*/g,".*")+"$").test(e)},throttle(e,t){let s;return function(...i){s||(e.apply(this,i),s=!0,setTimeout(()=>s=!1,t))}},safeParse(e){try{return JSON.parse(e)}catch(e){return null}},now:()=>performance.now()};class o{constructor(e){this.config=e,this.levels={error:0,warn:1,info:2,debug:3}}_shouldLog(e){return!!this.config.debug&&this.levels[e]<=this.levels[this.config.logLevel]}_format(e,t,...i){return[`[${s}] [${e.toUpperCase()}]`,t,...i]}error(e,...t){this._shouldLog("error")&&console.error(...this._format("error",e,...t))}warn(e,...t){this._shouldLog("warn")&&console.warn(...this._format("warn",e,...t))}info(e,...t){this._shouldLog("info")&&console.info(...this._format("info",e,...t))}debug(e,...t){this._shouldLog("debug")&&console.log(...this._format("debug",e,...t))}}class c{constructor(e,t){this.config=e,this.logger=t,this.events=new Map,this.onceEvents=new Set}on(e,t){if("function"!=typeof t)throw new TypeError("Callback must be a function");return(Array.isArray(e)?e:[e]).forEach(e=>{this.events.has(e)||this.events.set(e,new Set);const s=this.events.get(e);s.size>=this.config.maxListenersPerEvent?this.logger.warn(`Max listeners (${this.config.maxListenersPerEvent}) reached for event: ${e}`):(s.add(t),this.logger.debug(`Listener added for event: ${e}`))}),()=>this.off(e,t)}once(e,t){const s=(...i)=>{this.off(e,s),t(...i)};return this.onceEvents.add(s),this.on(e,s)}off(e,t){(Array.isArray(e)?e:[e]).forEach(e=>{const s=this.events.get(e);s&&(s.delete(t),0===s.size&&this.events.delete(e),this.logger.debug(`Listener removed for event: ${e}`))})}offAll(e){e?(this.events.delete(e),this.logger.debug(`All listeners removed for event: ${e}`)):(this.events.clear(),this.onceEvents.clear(),this.logger.debug("All listeners removed"))}emit(e,t){const s=new Set;return this.events.has(e)&&this.events.get(e).forEach(e=>s.add(e)),this.events.forEach((t,i)=>{i.includes("*")&&n.matchesPattern(e,i)&&t.forEach(e=>s.add(e))}),s.forEach(s=>{try{if("isolate"===this.config.errorHandling)setTimeout(()=>{try{s(e,t)}catch(t){this.logger.error(`Error in listener for ${e}:`,t)}},0);else if("suppress"===this.config.errorHandling)try{s(e,t)}catch(t){this.logger.error(`Error in listener for ${e}:`,t)}else s(e,t)}catch(t){this.logger.error(`Fatal error in listener for ${e}:`,t)}}),s.size}listenerCount(e){if(!e){let e=0;return this.events.forEach(t=>e+=t.size),e}const t=this.events.get(e);return t?t.size:0}eventNames(){return Array.from(this.events.keys())}}class a{constructor(){this.metrics={totalEvents:0,eventsPerType:new Map,processingTimes:[],avgProcessingTime:0,peakProcessingTime:0,droppedEvents:0,errors:0,startTime:Date.now(),lastReset:Date.now()},this.maxSamples=1e3}recordEvent(e,t){this.metrics.totalEvents++;const s=this.metrics.eventsPerType.get(e)||0;this.metrics.eventsPerType.set(e,s+1),this.metrics.processingTimes.push(t),this.metrics.processingTimes.length>this.maxSamples&&this.metrics.processingTimes.shift(),this.metrics.avgProcessingTime=this.metrics.processingTimes.reduce((e,t)=>e+t,0)/this.metrics.processingTimes.length,t>this.metrics.peakProcessingTime&&(this.metrics.peakProcessingTime=t)}recordError(){this.metrics.errors++}recordDropped(){this.metrics.droppedEvents++}getMetrics(){const e=Date.now()-this.metrics.startTime,t=this.metrics.totalEvents/(e/1e3);return{...this.metrics,uptime:e,eventsPerSecond:t.toFixed(2),topEvents:Array.from(this.metrics.eventsPerType.entries()).sort((e,t)=>t[1]-e[1]).slice(0,10)}}reset(){this.metrics.totalEvents=0,this.metrics.eventsPerType.clear(),this.metrics.processingTimes=[],this.metrics.avgProcessingTime=0,this.metrics.peakProcessingTime=0,this.metrics.droppedEvents=0,this.metrics.errors=0,this.metrics.lastReset=Date.now()}}class h{constructor(e,t){this.config=e,this.logger=t,this.discoveries=new Map,this.isDiscovering=!1,this.discoveryResolve=null}start(e=6e4){return this.isDiscovering?Promise.reject(new Error("Discovery already in progress")):(this.isDiscovering=!0,this.discoveries.clear(),this.logger.info(`Starting event discovery for ${e}ms`),new Promise(t=>{this.discoveryResolve=t,setTimeout(()=>{this.stop()},e)}))}stop(){if(!this.isDiscovering)return;this.isDiscovering=!1;const e=this.getResults();this.logger.info(`Discovery complete. Found ${e.length} event types`),this.discoveryResolve&&(this.discoveryResolve(e),this.discoveryResolve=null)}record(e,t){if(!this.isDiscovering)return;if(this.discoveries.size>=this.config.discoveryLimit)return;this.discoveries.has(e)||this.discoveries.set(e,{type:e,count:0,firstSeen:Date.now(),lastSeen:Date.now(),samples:[]});const s=this.discoveries.get(e);s.count++,s.lastSeen=Date.now(),s.samples.length<3&&s.samples.push({timestamp:Date.now(),data:n.deepClone(t)})}getResults(){return Array.from(this.discoveries.values()).sort((e,t)=>t.count-e.count)}}class l{constructor(e,t){this.config=e,this.processor=t,this.queue=[],this.timer=null,this.processing=!1,this.logger=null}updateConfig(e){const t=this.config.batchInterval;this.config=e,this.logger=new o(this.config),t!==e.batchInterval&&this.timer&&(this.logger.debug(`Restarting batch timer: ${t}ms → ${e.batchInterval}ms`),clearTimeout(this.timer),this.timer=setTimeout(()=>this.flush(),this.config.batchInterval))}add(e){this.config.enableBatching?(this.queue.push(e),this.timer||(this.logger&&this.logger.debug(`Starting batch timer with ${this.config.batchInterval}ms interval (queue: ${this.queue.length})`),this.timer=setTimeout(()=>this.flush(),this.config.batchInterval)),this.queue.length>=this.config.maxBatchSize&&this.flush()):this.processor([e])}flush(){if(this.processing||0===this.queue.length)return;this.processing=!0,this.timer&&(clearTimeout(this.timer),this.timer=null);const e=this.queue.splice(0,this.config.maxBatchSize);try{this.processor(e)}catch(e){console.error("[MWI-Moonitoring] Batch processing error:",e)}finally{this.processing=!1,this.queue.length>0&&!this.timer&&(this.logger&&this.logger.debug(`Scheduling next batch timer with ${this.config.batchInterval}ms interval (remaining: ${this.queue.length})`),this.timer=setTimeout(()=>this.flush(),this.config.batchInterval))}}clear(){this.queue=[],this.timer&&(clearTimeout(this.timer),this.timer=null)}size(){return this.queue.length}}const g=new class{constructor(){this.isHooked=!1,this.originalGet=null,this.instances=new Set}addInstance(e){this.instances.add(e),this.isHooked||this.installHook()}removeInstance(e){this.instances.delete(e),0===this.instances.size&&this.isHooked&&this.removeHook()}installHook(){if(!this.isHooked)try{const e=Object.getOwnPropertyDescriptor(MessageEvent.prototype,"data");if(!e||!e.get)throw new Error("Cannot access MessageEvent.prototype.data");this.originalGet=e.get;const t=this;e.get=function(){const e=this.currentTarget;if(!(e instanceof WebSocket))return t.originalGet.call(this);if(!r.some(t=>e.url&&e.url.indexOf(t)>-1))return t.originalGet.call(this);const s=t.originalGet.call(this);return Object.defineProperty(this,"data",{value:s}),setTimeout(()=>t.distributeMessage(s),0),s},Object.defineProperty(MessageEvent.prototype,"data",e),this.isHooked=!0,console.log("[MWI-Moonitoring] Global WebSocket hook installed successfully")}catch(e){throw console.error("[MWI-Moonitoring] Failed to install WebSocket hook:",e),e}}removeHook(){if(this.isHooked&&this.originalGet)try{const e=Object.getOwnPropertyDescriptor(MessageEvent.prototype,"data");e.get=this.originalGet,Object.defineProperty(MessageEvent.prototype,"data",e),this.isHooked=!1,this.originalGet=null,console.log("[MWI-Moonitoring] Global WebSocket hook removed")}catch(e){console.error("[MWI-Moonitoring] Failed to remove WebSocket hook:",e)}}distributeMessage(e){if("string"!=typeof e||e.length<2)return;if("{"!==e[0]&&"["!==e[0])return;const t=n.safeParse(e);t&&t.type&&this.instances.forEach(e=>{try{e.receiveMessage(t.type,t,Date.now())}catch(e){console.error("[MWI-Moonitoring] Error distributing message to instance:",e)}})}};class d{constructor(e={}){this.id=Math.random().toString(36).substr(2,9),this.config={...i,...e},this.logger=new o(this.config),this.emitter=new c(this.config,this.logger),this.monitor=new a,this.discovery=new h(this.config,this.logger),this.queue=new l(this.config,this.processBatch.bind(this)),this.queue.updateConfig(this.config),this.eventHistory=[],this.eventCache=new Map,this.isDestroyed=!1,g.addInstance(this),this.logger.info(`WebSocket instance ${this.id} created`),this._initialized=!0}destroy(){this.isDestroyed||(this.isDestroyed=!0,g.removeInstance(this),this.emitter.offAll(),this.eventHistory=[],this.eventCache.clear(),this.queue.clear(),this.monitor.reset(),this.logger.info(`WebSocket instance ${this.id} destroyed`))}isReady(){return!this.isDestroyed&&g.isHooked}receiveMessage(e,t,s){if(this.isDestroyed)return;const i=n.now();try{if(this.config.eventBlacklist.includes(e))return void this.monitor.recordDropped();if(this.config.eventWhitelist.length>0&&!this.config.eventWhitelist.includes(e))return void this.monitor.recordDropped();this.queue.add({type:e,data:t,timestamp:s}),(this.config.enableDiscovery||this.discovery.isDiscovering)&&this.discovery.record(e,t);const r=n.now()-i;this.monitor.recordEvent(e,r)}catch(t){this.monitor.recordError(),this.logger.error(`Error processing event ${e}:`,t)}}processBatch(e){const t=n.now();e.forEach(e=>{try{if(this.eventHistory.length>=this.config.historySize&&this.eventHistory.shift(),this.eventHistory.push(e),this.config.enableCache&&(this.eventCache.set(e.type,e),this.eventCache.size>this.config.cacheSize)){const e=this.eventCache.keys().next().value;this.eventCache.delete(e)}const t=this.emitter.emit(e.type,e.data);t>0&&this.logger.debug(`Event ${e.type} emitted to ${t} listeners`)}catch(t){this.monitor.recordError(),this.logger.error(`Error processing event ${e.type}:`,t)}});const s=n.now()-t;s>10&&this.logger.warn(`Batch processing took ${s.toFixed(2)}ms for ${e.length} messages`)}configure(e){const t={...this.config};this.config={...this.config,...e},this.logger=new o(this.config),this.emitter.config=this.config,this.discovery.config=this.config,this.queue.updateConfig(this.config),this.logger.info(`Instance ${this.id} configuration updated:`,{...e,_batchIntervalChanged:t.batchInterval!==this.config.batchInterval}),this===u.defaultInstance&&this.logger.warn("Default instance configuration changed - this affects all addons using the shared instance")}getConfig(){return{...this.config}}getEventHistory(e){return e?this.eventHistory.slice(-e):[...this.eventHistory]}getCachedEvent(e){return this.eventCache.get(e)}clear(){this.eventHistory=[],this.eventCache.clear(),this.queue.clear(),this.monitor.reset(),this.logger.info(`Instance ${this.id} data cleared`)}}const u=new class{constructor(){this.instances=new Map,this.defaultInstance=null}createInstance(e={}){const t=new d(e);return this.instances.set(t.id,t),t}getDefaultInstance(){return this.defaultInstance||(this.defaultInstance=this.createInstance()),this.defaultInstance}destroyInstance(e){const t="string"==typeof e?e:e.id,s=this.instances.get(t);s&&(s.destroy(),this.instances.delete(t),s===this.defaultInstance&&(this.defaultInstance=null))}destroyAll(){this.instances.forEach(e=>e.destroy()),this.instances.clear(),this.defaultInstance=null}},f=()=>u.getDefaultInstance(),m={version:t,_initialized:!0,createInstance(e={}){const s=u.createInstance(e);return{id:s.id,version:t,on:(e,t)=>s.emitter.on(e,t),once:(e,t)=>s.emitter.once(e,t),off:(e,t)=>s.emitter.off(e,t),offAll:e=>s.emitter.offAll(e),emit:(e,t)=>s.emitter.emit(e,t),discover:async(e=6e4)=>{const t=s.config.enableDiscovery;s.configure({enableDiscovery:!0});const i=await s.discovery.start(e);return s.configure({enableDiscovery:t}),i},getEventHistory:e=>s.getEventHistory(e),getCachedEvent:e=>s.getCachedEvent(e),configure:e=>s.configure(e),getConfig:()=>s.getConfig(),getMetrics:()=>s.monitor.getMetrics(),resetMetrics:()=>s.monitor.reset(),getEventCount:e=>e?s.monitor.metrics.eventsPerType.get(e)||0:s.monitor.metrics.totalEvents,listenerCount:e=>s.emitter.listenerCount(e),getEventTypes:()=>s.emitter.eventNames(),isReady:()=>s.isReady(),waitForReady:()=>new Promise(e=>{s.isReady()?e():setTimeout(e,100)}),clear:()=>s.clear(),destroy:()=>{u.destroyInstance(s)},enableProfiling:e=>{s.configure({debug:e,logLevel:e?"debug":"warn"})}}},on:(e,t)=>f().emitter.on(e,t),once:(e,t)=>f().emitter.once(e,t),off:(e,t)=>f().emitter.off(e,t),offAll:e=>f().emitter.offAll(e),emit:(e,t)=>f().emitter.emit(e,t),async discover(e=6e4){const t=f(),s=t.config.enableDiscovery;t.configure({enableDiscovery:!0});const i=await t.discovery.start(e);return t.configure({enableDiscovery:s}),i},getEventHistory:e=>f().getEventHistory(e),getEventTypes:()=>f().emitter.eventNames(),getEventCount(e){const t=f();return e?t.monitor.metrics.eventsPerType.get(e)||0:t.monitor.metrics.totalEvents},getCachedEvent:e=>f().getCachedEvent(e),getMetrics:()=>f().monitor.getMetrics(),resetMetrics(){f().monitor.reset()},enableProfiling(e){f().configure({debug:e,logLevel:e?"debug":"warn"})},configure(e){console.warn(`[${s}] WARNING: configure() affects ALL addons using the shared instance. Consider using MWIWebSocket.createInstance() for isolated configuration.`),f().configure(e)},getConfig:()=>f().getConfig(),isReady:()=>g.isHooked,waitForReady:()=>new Promise(e=>{g.isHooked?e():(f(),setTimeout(e,100))}),listenerCount:e=>f().emitter.listenerCount(e),installHook(){g.installHook()},removeHook(){g.removeHook()},clear(){f().clear()},destroy(){u.destroyAll(),g.removeHook()},getInstanceInfo:()=>({count:u.instances.size,instances:Array.from(u.instances.values()).map(e=>({id:e.id,config:e.getConfig(),listenerCount:e.emitter.listenerCount(),eventCount:e.monitor.metrics.totalEvents})),globalHookInstalled:g.isHooked})};e.MWIWebSocket=m,"undefined"!=typeof module&&module.exports&&(module.exports=m),"function"==typeof define&&define.amd&&define([],function(){return m})}("undefined"!=typeof window?window:this);